<template lang='pug'>
  Question(
    :index.sync='index'
    :props.sync="props"
    :questions.sync='questions'
    :optionList.sync='optionList'
    :groupUserAnswer.sync='groupUserAnswer'
    :canHandleAnser.sync='canHandleAnser')
</template>

<script>
  import wepy from 'wepy'
  import Question from './question'

  import { getQuestions, postAnswer, getProps, postProp, postUserAnswer } from '@/utils/api'
  import md5 from 'blueimp-md5'
  import { transformObject } from '@/utils/utils'
  export default class AnswerPage extends wepy.page {
    data = {
      lastOutIndex: 0,                // 最后一个淘汰题的索引
      lastInIndex: 0,                 // 最后一个晋级题的索引
      index: 0,                       // 索引
      pid: '',                        // pid
      answer: '',                     // 提交的答案
      questions: [],                  // 本期所有题目信息
      currentQuestion: {},            // 正在作答的题
      canHandleAnser: true,           // 是否能够发送请求处理答案
      props: [],                      // 道具列表
      groupUserAnswer: [],            // 随机三个当前排名前20用的答案
      optionList: [],                 // 当前已答用户的每个选项的比例
    }

    components = {
      Question
    }

    watch = {
      questions: () => {
        wepy.hideLoading()
      }
    }

    events = {
      'updateOptionAndQuesion': (currentQuestion) => {
        this.currentQuestion = currentQuestion
      },
      'handleAnswer': async () => {
        let choice = this.currentQuestion.choice
        let answer = ''
        for (let i = 0; i < choice.length; i++) {
          if (choice[i].checked) {
            answer += `${choice[i].option} `
          }
        }
        this.answer = answer.trim().split('').sort().map((option) => {
          if (option) return option
        }).join('').trim()
        this.canHandleAnser = false
        this.$apply()
        this.$invoke(this.$com.Question.$com.Timer, 'clearTimer')

        let params = {
          method: 'POST',
          data: {
            pid: this.pid,
            qid: this.currentQuestion._id,
            finished: 0,
            answer: this.answer
          }
        }
        // 判断正在答的题是否为最后一题
        if (this.index < this.questions.length - 1) {
          await this.handleAnswerResponse(await postAnswer(params))
        } else {
          params.data.finished = 1
          await this.handleAnswerResponse(await postAnswer(params))
        }

        this.canHandleAnser = true
        this.currentQuestion = {}
        this.$apply()
      },
      'useProp': async (dataset) => {
        try {
          let { name, num } = dataset
          if (num === 0) return

          let { type, _id: qid } = this.questions[this.index]
          let salt = 'GeEkHeAl@YZST'
          let timestamp = new Date().getTime()
          let sign = md5(`${timestamp}${salt}`)
          let params = {
            method: 'POST',
            data: {
              qid,
              name,
              sign,
              timestamp,
              pid: this.pid,
            }
          }

          switch (name) {
            case 'ZRSYTX':
              if (type === 2) {
                wepy.showToast({
                  title: '单选题才可以用该道具',
                  icon: 'none'
                })
                return
              }
              let { data: { error: zrError, eAnswer: zrResult } } = await postProp(params)
              if (zrError === 0) {
                this.markErrorOption(zrResult)
                this.props.forEach(item => {
                  if (item.name === name && item.num > 0) {
                    item.num--
                    this.$apply()
                  }
                })
              }
              break
            case 'HSZWRNS':
              if (type === 2) {
                wepy.showToast({
                  title: '单选题才可以用该道具',
                  icon: 'none'
                })
                return
              }
              let { data: { error: hsError, eAnswer: hsAnswer } } = await postProp(params)
              if (hsError === 0) {
                this.markErrorOption(hsAnswer)
                this.props.forEach(item => {
                  if (item.name === name && item.num > 0) {
                    item.num--
                    this.$apply()
                  }
                })
              }
              break
            case 'XBDDA':
              let { data: { error: xbError, data } } = await postProp(params)
              if (data) this.$broadcast('toggleXbResult', true)
              if (xbError === 0) {
                this.formatUserAnswer(data)
                this.props.forEach(item => {
                  if (item.name === name && item.num > 0) {
                    item.num--
                    this.$apply()
                  }
                })
              } else if (xbError === 6666) {
                wepy.showToast({
                  title: '暂无该题的答题记录',
                  icon: 'none'
                })
              }
              break
            case 'DrWhyXC':
              let { data: { error: drError, eAnswer: drAnswer } } = await postProp(params)
              if (drAnswer) this.$broadcast('toggleDrWhyResult', true)
              if (drError === 0) {
                this.formatOptionList(drAnswer)
                this.props.forEach(item => {
                  if (item.name === name && item.num > 0) {
                    item.num--
                    this.$apply()
                  }
                })
              } else if (drError === 6666) {
                wepy.showToast({
                  title: '暂无该题的答题记录',
                  icon: 'none'
                })
              }
              break
          }
        } catch (error) {
          console.log('error', error)
        }
      },
      'seeUserAnswer': async (dataset) => {
        let { uid, index } = dataset
        let { _id: qid } = this.questions[this.index]
        let salt = 'GeEkHeAl@YZST'
        let timestamp = new Date().getTime()
        let sign = md5(`${timestamp}${salt}`)
        let params = {
          method: 'POST',
          data: {
            uid,
            qid,
            sign,
            timestamp,
            pid: this.pid,
          }
        }
        let { data: { eAnswer } } = await postUserAnswer(params)
        eAnswer.split('').forEach(el => {
          this.questions[this.index].choice.forEach(item => {
            if (item.option === el) {
              this.groupUserAnswer[index].answer += item.showOption
              this.$apply()
            }
          })
        })
      }
    }

    onLoad (params) {
      this.initData(params)
    }

    async initData (params) {
      try {
        wepy.showLoading({
          title: '题目加载中',
          mask: true
        })
        let { pid = '', total_score = 0, total_bonus = 0 } = params
        this.pid = pid
        this.total_score = total_score
        this.total_bonus = total_bonus
        this.questions = await this.getQuestions()
        this.$apply()
        await this.getProps()
        this.$invoke(this.$com.Question.$com.Timer, 'startTimer')
      } catch (error) {
        wepy.hideLoading()
        wepy.showToast({
          title: '数据加载失败',
          icon: 'none'
        })
        wepy.navigateBack({
          delta: 1
        })
      }
    }

    // 获取道具
    async getProps () {
      let { data: { props } } = await getProps()
      if (props.length === 0) return
      this.formatProps(props).forEach(item => {
        if (item.name !== 'double' && item.name !== 'r_card') {
          this.props.push(item)
          this.$apply()
        }
      })
    }

    // 格式化道具数据格式
    formatProps (props) {
      for (let [i, item] of props.entries()) {
        switch (item.name) {
          case 'HSZWRNS':
            props[i] = {
              ...item,
              cnName: '护士长的温柔凝视',
              src: `/images/props1.svg`,
              features: '去掉单选题的一个错误答案',
              wrapperBg: '#ff71a0',
              style: {
                w: 36,
                h: 63,
                marginT: 10,
                marginL: 10
              }
            }
            break
          case 'ZRSYTX':
            props[i] = {
              ...item,
              cnName: '主任的善意提醒',
              features: '去掉单选题的两个错误答案',
              src: `/images/props2.svg`,
              wrapperBg: '#73dd71',
              style: {
                w: 36,
                h: 55,
                marginT: 5,
                marginL: 14
              }
            }
            break
          case 'DrWhyXC':
            props[i] = {
              ...item,
              cnName: 'DrWhy的小抄',
              features: '查看当前已答题用户的每个选项比例',
              src: `/images/props3.svg`,
              wrapperBg: '#72cced',
              style: {
                w: 39,
                h: 59,
                marginT: 5,
                marginL: 12
              }
            }
            break
          case 'XBDDA':
            props[i] = {
              ...item,
              cnName: '学霸的选择题答案',
              features: '查看随机三个当前排名前20用户的答案',
              src: `/images/props4.svg`,
              wrapperBg: '#ffdf13',
              nameBg: '#98840a',
              style: {
                w: 50,
                h: 59,
                marginT: 14,
                marginL: 10
              }
            }
            break
          case 'r_card':
            props[i] = {
              ...item,
              cnName: '复活卡',
              features: '一次复活的机会',
              src: `/images/props5.svg`,
              wrapperBg: '#ec5858',
              nameBg: '#863535',
              style: {
                w: 50,
                h: 59,
                marginT: 10,
                marginL: 10
              }
            }
            break
          case 'double':
            props[i] = {
              ...item,
              cnName: '奖金翻倍卡',
              features: '奖金系数翻倍',
              src: `/images/props6.svg`,
              wrapperBg: '#50e3c2',
              nameBg: '#359680',
              style: {
                w: 92,
                h: 126,
                marginT: 10,
                marginL: 10
              }
            }
            break
        }
      }
      return props
    }

    // 标记出错误选项
    markErrorOption (aErrorOption) {
      aErrorOption.forEach((errorOption) => {
        this.questions[this.index].choice.forEach(item => {
          if (errorOption === item.option) {
            item.disabled = true
            this.$apply()
          }
        })
      })
    }

    // 格式化学霸的答案数据格式
    formatUserAnswer (groupUserAnswer) {
      this.groupUserAnswer = groupUserAnswer.map(item => {
        let { user: { avatar, nickName, uid } } = item
        if (!avatar) avatar = '/images/avatar-default.svg'
        if (!nickName) nickName = '匿名用户'
        return {avatar, nickName, uid, answer: ''}
      })
      this.$apply()
    }

    // 格式选项占比数据格式
    formatOptionList (orginOption) {
      let optionList = []
      let obj = {}
      for (let key of Object.keys(orginOption)) {
        obj = {
          option: key.split(''),
          optionStr: '',
          proportion: orginOption[key],
          proportionWidth: orginOption[key] < 7 ? 32 : 195 * orginOption[key] / 100,
          proportionValue: `${orginOption[key]}%`
        }
        obj.option.forEach(option => {
          this.questions[this.index].choice.forEach(item => {
            if (option === item.option) {
              obj.optionStr += item.showOption
            }
          })
        })
        obj.optionStr = obj.optionStr.split('').sort().join('')
        obj.optionStr = obj.optionStr ? obj.optionStr : '空'
        optionList.push(obj)
      }
      this.optionList = optionList
      this.$apply()
    }

    // 获取本期所有题
    async getQuestions () {
      try {
        let params = {
          method: 'POST',
          data: {
            pid: this.pid
          }
        }
        let { data: { data: questions } } = await getQuestions(params)
        let quesitonsOutStates = []
        let showOptions = ['A', 'B', 'C', 'D', 'E', 'F']
        for (let i of questions.keys()) {
          let choice = []
          for (let j of questions[i].choice.keys()) {
            choice.push(questions[i].choice[j])
          }
          choice = this.shuffle(choice.map(item => transformObject(item)))

          for (let [k, item] of choice.entries()) {
            item.showOption = showOptions[k]
            item.disabled = false
          }

          questions[i].choice = choice
          quesitonsOutStates.push(questions[i].out)
        }
        this.lastOutIndex = quesitonsOutStates.lastIndexOf(1)
        this.lastInIndex = quesitonsOutStates.lastIndexOf(0)
        this.$apply()
        return questions
      } catch (error) {

      }
    }

    // 处理答题响应
    async handleAnswerResponse (res) {
      try {
        let { data: { data = 0, alive = 0, finished = 0, total = 0, error = 0 } } = res
        let { out } = this.questions[this.index]

        if (error && !finished) {
          wepy.showToast({
            title: 'error',
            icon: 'none'
          })
          this.nextQuestion()
        }

        if (out) {
          if (this.index === this.lastOutIndex) {
            if (data && !alive) {
              await this.showTip('答对啦！恭喜晋级！', true)
              this.nextQuestion()
            }
            if (data && alive) {
              await this.showTip('自动使用复活卡！恭喜晋级！', true)
              this.nextQuestion()
            }
            if (!data && finished) {
              await this.showTip('很遗憾！您被淘汰了！', false)
              this.$invoke(this.$com.Question.$com.Timer, 'clearTimer')
              wepy.redirectTo({
                url: `/pages/result/index?score=${total}&pid=${this.pid}&total_score=${this.total_score}`
              })
            }
          } else {
            if (data && !alive) {
              await this.showTip('答对啦！好棒！', true)
              this.nextQuestion()
            }
            if (data && alive) {
              await this.showTip('答错啦！自动使用复活卡！', true)
              this.nextQuestion()
            }
            if (!data && finished) {
              await this.showTip('很遗憾！您被淘汰了！', false)
              this.$invoke(this.$com.Question.$com.Timer, 'clearTimer')
              wepy.redirectTo({
                url: `/pages/result/index?score=${total}&pid=${this.pid}&total_score=${this.total_score}`
              })
            }
          }
        } else {
          if (this.index === this.lastInIndex) {
            if (data && finished) {
              await this.showTip('答对啦！答题结束！', true)
              this.$invoke(this.$com.Question.$com.Timer, 'clearTimer')
              wepy.redirectTo({
                url: `/pages/result/index?isShowRewardBtn=1&score=${total}&pid=${this.pid}&total_bonus=${this.total_bonus}&total_score=${this.total_score}`
              })
            }
            if (!data && finished) {
              await this.showTip('答错啦！答题结束！', false)
              this.$invoke(this.$com.Question.$com.Timer, 'clearTimer')
              wepy.redirectTo({
                url: `/pages/result/index?isShowRewardBtn=1&score=${total}&pid=${this.pid}&total_bonus=${this.total_bonus}&total_score=${this.total_score}`
              })
            }
          } else {
            if (data && !finished) {
              await this.showTip('答对啦！好棒！', true)
              this.nextQuestion()
            }
            if (!data && !finished) {
              await this.showTip('答错啦！下一题加油哦！', false)
              this.nextQuestion()
            }
          }
        }
      } catch (error) {
        wepy.showToast({
          title: '网络异常',
          icon: 'none'
        })
        this.nextQuestion()
      }
    }

    // Promise化setTimeout
    async timeout (ms) {
      return new Promise((resolve, reject) => {
        this.timer = setTimeout(resolve, ms)
      })
    }

    // 展示提示框
    async showTip (tipcontent, isCorrect) {
      this.$invoke(this.$com.Question.$com.Tip, 'showTip', tipcontent, isCorrect)
      await this.timeout(1000)
      this.$invoke(this.$com.Question.$com.Tip, 'hideTip', tipcontent, isCorrect)
    }

    // 切换到下一题
    nextQuestion () {
      this.index++
      this.$apply()
      this.$invoke(this.$com.Question.$com.Timer, 'startTimer')
    }

    // 随机打乱数组
    shuffle (arr) {
      return arr.sort(() => {
        return Math.random() - 0.5
      })
    }
  }
</script>

<style lang='scss'>
</style>
